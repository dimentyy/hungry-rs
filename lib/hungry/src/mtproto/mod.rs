mod auth_key;
mod message;
mod msg;
mod msg_id;
mod pack;
mod seq_no;
mod unpack;

use crate::envelopes;

pub use auth_key::{AuthKey, MsgKey};
pub use message::{DecryptedMessage, EncryptedMessage, Message, PlainMessage};
pub use msg::Msg;
pub use msg_id::{MsgId, MsgIds};
pub use pack::{pack_encrypted, pack_plain};
pub use seq_no::{SeqNo, SeqNos};
pub use unpack::MsgKeyCheckError;

/// # Session
///
/// A (random) 64-bit number generated by the client to distinguish
/// between individual sessions (for example, between different
/// instances of the application, created with the same authorization key).
/// The session in conjunction with the key identifier corresponds
/// to an application instance. The server can maintain session state.
/// Under no circumstances can a message meant for one session be sent
/// into a different session. The server may unilaterally forget any
/// client sessions; clients should be able to handle this.
///
/// ---
/// https://core.telegram.org/mtproto/description#session
pub type Session = i64;

/// # Server Salt
///
/// A (random) 64-bit number changed every 30 minutes (separately
/// for each session) at the request of the server. All subsequent
/// messages must contain the new salt (although, messages with
/// the old salt are still accepted for a further 1800 seconds).
/// Required to protect against replay attacks and certain tricks associated
/// with adjusting the client clock to a moment in the distant future.
///
/// ---
/// https://core.telegram.org/mtproto/description#server-salt
pub type Salt = i64;

/// For MTProto 2.0, the algorithm for computing
/// aes_key and aes_iv from auth_key and msg_key is
/// <...> where x = 0 for messages from client to
/// server and x = 8 for those from server to client.
///
/// ---
/// https://core.telegram.org/mtproto/description#defining-aes-key-and-initialization-vector
#[repr(usize)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Side {
    Client = 0,
    Server = 8,
}

impl Side {
    #[inline(always)]
    pub const fn x(self) -> usize {
        self as usize
    }
}

envelopes! {
    pub PlainEnvelope => PlainEnvelopeSize:
        PlainMessage::HEADER_LEN,
        0;          // no padding
    pub EncryptedEnvelope => EncryptedEnvelopeSize:
        EncryptedMessage::HEADER_LEN + DecryptedMessage::HEADER_LEN + Msg::HEADER_LEN,
        1024;       // padding (12..1024)
}
